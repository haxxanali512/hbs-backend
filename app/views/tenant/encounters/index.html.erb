<div class="min-h-screen bg-gray-50 py-8">
  <div class="w-full mx-auto px-4 sm:px-6 lg:px-8">
    <!-- Header -->
    <div class="mb-8">
      <div class="flex justify-between items-center">
        <div>
          <h1 class="text-3xl font-bold text-gray-900">Encounters</h1>
          <p class="mt-2 text-gray-600">Manage patient encounters and billing</p>
        </div>
        <div class="space-x-2">
          <%= link_to "Prepare a New Encounter",
                      workflow_tenant_encounters_path,
                      class: "bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg transition-colors" %>
        </div>
      </div>
    </div>

    <!-- Filters -->
    <%
      @search_placeholder = "Patient name..."
      @status_options = @statuses
      @provider_options = @providers
      @patient_options = @patients
      @specialty_options = @specialties
      @cascaded_options = ["Not Cascaded", "Cascaded"] unless @show_submitted_only || @show_queued_only
      @show_date_range = true
      @encounter_type_options = [["All Encounters", ""], ["Submitted Encounters", "submitted"], ["Ready to be sent", "queued"]]
      @show_encounter_type_filter = true
      @show_claim_status_filter = @show_submitted_only
      @show_queued_only = params[:submitted_filter] == "queued"
    %>
    <%= render "shared/filters" %>

    <!-- Send for Billing Button (only shown when queued filter is active) -->
    <div id="send_for_billing_section">
      <% if @show_queued_only %>
        <%= render partial: "tenant/encounters/send_for_billing_button", locals: { encounters: @encounters } %>
      <% end %>
    </div>

    <!-- Encounters Table -->
    <div id="encounters_table_frame">
      <%= render partial: "tenant/encounters/table", locals: { encounters: @encounters, show_submitted_only: @show_submitted_only, show_queued_only: @show_queued_only, pagy: @pagy } %>
    </div>
  </div>
</div>

<script>
  // Use event delegation that works across Turbo Stream updates
  (function() {
    function updateSubmitState() {
      const tableBody = document.querySelector('[data-encounter-selection-target="tableBody"]');
      const submitButton = document.getElementById('submit_queued_button');
      const encounterIdsInput = document.getElementById('encounter_ids_input');
      
      if (!tableBody) {
        if (submitButton) submitButton.disabled = true;
        return;
      }

      const checkedBoxes = tableBody.querySelectorAll('input[name="encounter_ids[]"]:checked');
      const hasSelections = checkedBoxes.length > 0;
      
      if (submitButton) {
        submitButton.disabled = !hasSelections;
      }

      // Update hidden input with selected IDs
      if (encounterIdsInput) {
        const selectedIds = Array.from(checkedBoxes).map(cb => cb.value);
        encounterIdsInput.value = selectedIds.join(',');
      }

      // Update select all checkbox state
      const selectAll = document.querySelector('[data-encounter-selection-target="selectAll"]');
      if (selectAll && tableBody) {
        const allCheckboxes = tableBody.querySelectorAll('input[name="encounter_ids[]"]');
        const checkedBoxes = tableBody.querySelectorAll('input[name="encounter_ids[]"]:checked');
        selectAll.checked = allCheckboxes.length > 0 && checkedBoxes.length === allCheckboxes.length;
        selectAll.indeterminate = checkedBoxes.length > 0 && checkedBoxes.length < allCheckboxes.length;
      }
    }

    // Use event delegation on document for checkboxes
    document.addEventListener('change', function(event) {
      if (event.target.name === 'encounter_ids[]') {
        updateSubmitState();
      } else if (event.target.getAttribute('data-encounter-selection-target') === 'selectAll') {
        const tableBody = document.querySelector('[data-encounter-selection-target="tableBody"]');
        if (tableBody) {
          const checkboxes = tableBody.querySelectorAll('input[name="encounter_ids[]"]');
          const isChecked = event.target.checked;
          checkboxes.forEach(checkbox => {
            checkbox.checked = isChecked;
          });
          updateSubmitState();
        }
      }
    });

    // Initialize on page load and after Turbo Stream updates
    function initialize() {
      updateSubmitState();
    }

    // Initialize on various Turbo events
    document.addEventListener('turbo:load', initialize);
    document.addEventListener('turbo:frame-load', function(event) {
      if (event.target.id === 'encounters_table_frame' || event.target.closest('#encounters_table_frame')) {
        setTimeout(initialize, 100);
      }
    });
    document.addEventListener('turbo:before-stream-render', function() {
      // Update state before stream renders
      setTimeout(initialize, 50);
    });
    document.addEventListener('turbo:after-stream-render', function() {
      setTimeout(initialize, 100);
    });
    // Also listen for turbo:submit-end to reinitialize after form submission
    document.addEventListener('turbo:submit-end', function(event) {
      if (event.detail && event.detail.success !== false) {
        setTimeout(initialize, 200);
      }
    });

    // Initial call
    initialize();
  })();
</script>

