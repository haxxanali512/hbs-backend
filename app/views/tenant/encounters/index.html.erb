<div class="min-h-screen bg-gray-50 py-8">
  <div class="w-full mx-auto px-4 sm:px-6 lg:px-8">
    <!-- Header -->
    <div class="mb-8">
      <div class="flex justify-between items-center">
        <div>
          <h1 class="text-3xl font-bold text-gray-900">Encounters</h1>
          <p class="mt-2 text-gray-600">Manage patient encounters and billing</p>
        </div>
        <div class="space-x-2">
          <%= link_to "Prepare a New Encounter",
                      workflow_tenant_encounters_path,
                      class: "bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-lg transition-colors" %>
        </div>
      </div>
    </div>

    <!-- Filters -->
    <%
      @search_placeholder = "Patient name..."
      @status_options = @statuses
      @provider_options = @providers
      @patient_options = @patients
      @specialty_options = @specialties
      @cascaded_options = ["Not Cascaded", "Cascaded"] unless @show_submitted_only || @show_queued_only
      @show_date_range = true
      @encounter_type_options = [["All Encounters", ""], ["Submitted Encounters", "submitted"], ["Ready to be sent", "queued"]]
      @show_encounter_type_filter = true
      @show_claim_status_filter = @show_submitted_only
      @show_queued_only = params[:submitted_filter] == "queued"
    %>
    <%= render "shared/filters" %>

    <!-- Send for Billing Button (only shown when queued filter is active) -->
    <% if @show_queued_only %>
      <div id="send_for_billing_section">
        <%= render partial: "tenant/encounters/send_for_billing_button", locals: { encounters: @encounters } %>
      </div>
    <% end %>

    <!-- Encounters Table -->
    <div id="encounters_table_frame">
      <%= render partial: "tenant/encounters/table", locals: { encounters: @encounters, show_submitted_only: @show_submitted_only, show_queued_only: @show_queued_only, pagy: @pagy } %>
    </div>
  </div>
</div>

<% if @show_queued_only %>
<script>
  (function() {
    function initializeEncounterSelection() {
      const selectAllCheckbox = document.querySelector('[data-encounter-selection-target="selectAll"]');
      const submitButton = document.getElementById('submit_queued_button');
      const encounterIdsInput = document.getElementById('encounter_ids_input');
      const tableBody = document.querySelector('[data-encounter-selection-target="tableBody"]');

      if (!tableBody) return;

      function updateSubmitState() {
        const checkedBoxes = tableBody.querySelectorAll('input[name="encounter_ids[]"]:checked');
        const hasSelections = checkedBoxes.length > 0;
        
        if (submitButton) {
          submitButton.disabled = !hasSelections;
        }

        // Update hidden input with selected IDs
        if (encounterIdsInput) {
          const selectedIds = Array.from(checkedBoxes).map(cb => cb.value);
          encounterIdsInput.value = selectedIds.join(',');
        }
      }

      function toggleAll(event) {
        const checkboxes = tableBody.querySelectorAll('input[name="encounter_ids[]"]');
        const isChecked = event.target.checked;
        
        checkboxes.forEach(checkbox => {
          checkbox.checked = isChecked;
        });
        
        updateSubmitState();
      }

      // Remove old event listeners by cloning and replacing
      const newSelectAll = selectAllCheckbox?.cloneNode(true);
      if (selectAllCheckbox && newSelectAll) {
        selectAllCheckbox.parentNode.replaceChild(newSelectAll, selectAllCheckbox);
        newSelectAll.addEventListener('change', toggleAll);
      }

      // Set up table body change listener
      tableBody.addEventListener('change', function(event) {
        if (event.target.name === 'encounter_ids[]') {
          updateSubmitState();
          
          // Update select all checkbox state
          const selectAll = document.querySelector('[data-encounter-selection-target="selectAll"]');
          if (selectAll) {
            const allCheckboxes = tableBody.querySelectorAll('input[name="encounter_ids[]"]');
            const checkedBoxes = tableBody.querySelectorAll('input[name="encounter_ids[]"]:checked');
            selectAll.checked = allCheckboxes.length > 0 && checkedBoxes.length === allCheckboxes.length;
            selectAll.indeterminate = checkedBoxes.length > 0 && checkedBoxes.length < allCheckboxes.length;
          }
        }
      });

      // Initialize state
      updateSubmitState();
    }

    // Initialize on page load
    initializeEncounterSelection();

    // Re-initialize on Turbo Stream updates
    document.addEventListener('turbo:frame-load', function(event) {
      if (event.target.id === 'encounters_table_frame') {
        setTimeout(initializeEncounterSelection, 100);
      }
    });

    // Also listen for turbo:load for full page loads
    document.addEventListener('turbo:load', initializeEncounterSelection);
  })();
</script>
<% end %>

